// Adapted from http=//hepunx.rl.ac.uk/~adye/jsspec11/llr.htm
// See this also: http://timmywillison.com/pres/operators/#precedence


Program=
          head:Element tail:Program ws_nl*
			{ console.log("program"); return { tag:"program", head: head, tail:tail }; }
		/	empty

Element=
         	FunctionLiteral
       /   Statement

//ParameterListOpt=
//          empty
//      /   ParameterList

ParameterList=          
         h:Identifier "," t:ParameterList
			{ console.log("parameterlist"); return { tag: "parameter_list", head: h, tail: t }; }
		/	Identifier

CompoundStatement=
          "{" ws_nl* code:Statements "}" ws_nl*
			{ console.log("compound"); return { tag: "compound", code: code }; }
		/	"{" e:empty "}" ws_nl*
			{ console.log("compound (empty)"); return { tag: "compound", code: e }; }

Statements=
          h:Statement t:Statements
			{ console.log("statements"); return { tag: "statements", head: h, tail: t}; }
		/	empty

Statement=
         e:empty ";" ws_nl*
			{ return e; }
      /   "if" ws_nl* c:Condition ifthen:Statement "else" ws_nl* ifelse:Statement
			{ return { tag: "if", condition:c, ifthen: ifthen, ifelse: ifelse}; }
      /  "if" ws_nl* c:Condition ifthen:Statement
			{ return { tag: "if", condition:c, ifthen: ifthen}; }
      /   "while" ws_nl* c:Condition s:Statement
			{ return { tag:"while", condition:c, body:s }; }
      /   ForParen ";" ws_nl* e1:Expression? ";" ws_nl* e2:Expression? ")" ws_nl* s:Statement
			{ return {tag:"for", condition:e1, inc:e2, body:s }}
      /   e:ForBegin ";" ws_nl* e1:Expression? ";" ws_nl* e2:Expression? ")" ws_nl* s:Statement
			{ return {tag:"for", init:e, condition:e1, inc:e2, body:s }}
      /   e:ForBegin "in" ws_nl* c:Expression ")" ws_nl* s:Statement
			{ return {tag:"for_each", init:e, collection:c, body:s }}
      /   "break" ws_nl* ";" ws_nl*
			{ return { tag: "break"}; }
      /   "continue" ws_nl* ";" ws_nl*
			{ return { tag:"continue"}; }
      /   "with" ws_nl* "(" ws_nl* e:Expression ")" ws_nl* s:Statement ws_nl*
			{ return { tag:"with", expression:e, body:s }; }
      /   "return" ws_nl* e:Expression? ";" ws_nl*
			{ return { tag:"return", expression:e}; }
      /   CompoundStatement
      /   v:VariablesOrExpression ";" ws_nl*
			{ return v; }

Condition=
          "(" ws_nl* e:Expression ")" ws_nl*
			{ return { tag:"condition", expression:e}; }

ForParen=
          "for" ws_nl* "(" ws_nl*

ForBegin=
          ForParen i:VariablesOrExpression ws_nl*
			{ return i; }

VariablesOrExpression=
          "var " ws_nl* v:Variables
			{ return { tag:"decl", vars:v}; }
     /    Expression

Variables=
          h:Variable "," ws_nl* t:Variables
			{ return { tag:"vars", head:head, tail:t}; }
		/	Variable

Variable=    
         left:Identifier "=" ws_nl* right:AssignmentExpression
			{ return { tag:"assign", left:left, right:right}; }
		/	Identifier

//ExpressionOpt=
//          empty
//     /    Expression

Expression=
         a:AssignmentExpression "," ws_nl* e:Expression
			{ return { tag:"expression", left:a, right:e}; }
		/	AssignmentExpression

AssignmentExpression=
		left:ConditionalExpression op:AssignmentOperator right:FunctionLiteral
			{ return { tag:"assignmentop", operator:op, left:left, right:right}; }
      /   left:ConditionalExpression op:AssignmentOperator right:AssignmentExpression
			{ return { tag:"assignmentop", operator:op, left:left, right:right}; }
		/	ConditionalExpression

ConditionalExpression=
         cond:OrExpression "?" ws_nl* iftrue:AssignmentExpression ":" ws_nl* iffalse:AssignmentExpression // Fix here, from "=" (???) to ":"
			{ return { tag:"conditionalop", condition:cond, iftrue:iftrue, iffalse:iffalse }; }
		/	OrExpression

OrExpression=
         l:AndExpression "||" ws_nl* r:OrExpression
			{ return { tag:"or", left:l, right:r}}
		/	AndExpression

AndExpression=
         l:BitwiseOrExpression "&&" ws_nl* r:AndExpression
			{ return { tag:"and", left:l, right:r}}
		/	BitwiseOrExpression

BitwiseOrExpression=
         l:BitwiseXorExpression "|" ws_nl* r:BitwiseOrExpression
			{ return { tag:"bor", left:l, right:r}}
		/	BitwiseXorExpression

BitwiseXorExpression=
         l:BitwiseAndExpression "^" ws_nl* r:BitwiseXorExpression
			{ return { tag:"bxor", left:l, right:r}}
		/	BitwiseAndExpression

BitwiseAndExpression=
         l:EqualityExpression "&" ws_nl* r:BitwiseAndExpression
			{ return { tag:"band", left:l, right:r}}
		/	EqualityExpression

EqualityExpression=
         l:RelationalExpression op:EqualityualityOperator r:EqualityExpression
			{ return { tag:"eq", op:op, left:l, right:r}}
		/	RelationalExpression

RelationalExpression=
         l:ShiftExpression op:RelationalationalOperator r:RelationalExpression // Fixed from RelationalExpression ... ShiftExpression, left recursion error
			{ return { tag:"rel", op:op, left:l, right:r}}
		/	ShiftExpression

// TODO: instanceof, in

ShiftExpression=
         l:AdditiveExpression op:ShiftOperator r:ShiftExpression
			{ return { tag:"shift", op:op, left:l, right:r}}
		/	AdditiveExpression

AdditiveExpression=
         l:MultiplicativeExpression op:AdditiveOperator r:AdditiveExpression
			{ return { tag:"add", op:op, left:l, right:r}; }
		/	MultiplicativeExpression

MultiplicativeExpression=
         l:UnaryExpression op:MultiplicativeOperator r:MultiplicativeExpression
			{ return { tag:"mult", op:op, left:l, right:r}; }
		/	UnaryExpression

UnaryExpression=
         "new" ws_nl+ c:Constructor
			{ return { tag:"create", constr:c}; }
     /    "delete" ws_nl+ m:MemberExpression
			{ return { tag:"destroy", member:m}; }
//     /    "-" UnaryExpression Not needed?
     /    op:UnaryOperator ws_nl* right:UnaryExpression
			{ return { tag:"unary", op:op, right:right}; }
     /    op:IncrementOperator ws_nl* operand:MemberExpression
			{ console.log("incl"); return { tag:"incl", op:op, operand:operand}; }
     /    operand:MemberExpression ws_nl* IncrementOperator
			{ console.log("incr"); return { tag:"incr", op:op, operand:operand}; }
     /     MemberExpression

Constructor=
          "this" ws_nl* "." ws_nl* c:ConstructorCall
			{ return { tag:"constructor", call:c }; }
     /    ConstructorCall

ConstructorCall=          
			id:Identifier "(" ws_nl* args:ArgumentList? ")" ws_nl*
			{ return { tag:"constr_call_fun", id:id, args:args }; }
		/  id:Identifier "." ws_nl* c:ConstructorCall
			{ return { tag:"constr_call_member", id:id, call:c }; }
		/	Identifier

MemberExpression=
		    p:PrimaryExpression "(" ws_nl* a:ArgumentList? ")" ws_nl*
			{ console.log("member_fun"); return { tag:"member_fun", left:p, arglist:a}; }
/**/  /   p:PrimaryExpression "." ws_nl* m:MemberExpression
			{ console.log("member_dot"); return  { tag:"member_dot", left:p, member:m}; }
		/   p:PrimaryExpression "[" ws_nl* e:Expression "]" ws_nl*
			{ console.log("member_arr"); return { tag:"member_arr", left:p, expression:e}; }		
		/	 PrimaryExpression

/*ArgumentListOpt=
          empty
     /    ArgumentList*/

ArgumentList=
         h:AssignmentExpression "," ws_nl* t:ArgumentList
			{ return { tag:"arglist", head:h, tail:t}; }
		/  h:AssignmentExpression
			{ return { tag:"arglist", head:h, tail:[]}; }

PrimaryExpression=
			"(" ws_nl* e:Expression ")" ws_nl*
			{ console.log("expression inside ()"); return e; }
     /    "false" ws_nl*
			{ return { tag:"boolean", value:false}; }
     /    "true" ws_nl*
			{ return { tag:"boolean", value:true}; }
     /    "null" ws_nl*
			{ return { tag:"null"}; }
     /    "this" ws_nl*
			{ return { tag:"this"}; }
	  /	 FunctionLiteral
     /    FloatingPointLiteral
     /    IntegerLiteral
     /    StringLiteral
     /    Identifier

FunctionLiteral=
			"function" ws_nl+ id:Identifier? "(" ws_nl* pars:ParameterList? ")" ws_nl* body:CompoundStatement
			{ console.log("function"); return { tag:"function", name: id , parameters: pars, body: body}; }

newline=[\r\n] / "\r\n"
ws_nl=[ \s\t] / newline

empty = 
	ws_nl* 
	{ console.log("empty"); return { tag:"empty" } }

Identifier=
	h:valid_1st_idchar t:valid_idchar* ws_nl*
	{ console.log("id = " + [h].concat(t).join('')); return { tag:"id", name:[h].concat(t).join('')}}

_AssignmentOperator="=" / "+=" / "-=" / "*=" / "/=" / "%=" / "<<=" / ">>=" / ">>>=" / "&=" / "^=" / "|="
AssignmentOperator = 
			i:_AssignmentOperator ws_nl*
			{ return i; }

_EqualityualityOperator="==" / "===" / "!=" / "!=="
EqualityualityOperator = 
			i:_EqualityualityOperator ws_nl*
			{ return i; }

_RelationalationalOperator=">=" / ">==" / "<=" / "<=="
RelationalationalOperator = 
			i:_RelationalationalOperator ws_nl*
			{ return i; }

_ShiftOperator="<<" / ">>" / "<<<" / ">>>"
ShiftOperator = 
			i:_ShiftOperator ws_nl*
			{ return i; }

_AdditiveOperator="+" / "-"
AdditiveOperator = 
			i:_AdditiveOperator ws_nl*
			{ return i; }

_MultiplicativeOperator="*" / "/" / "%"
MultiplicativeOperator = 
			i:_MultiplicativeOperator ws_nl*
			{ return i; }

_UnaryOperator="!" / "-" / "+" / "~" / "typeof" / "void"
UnaryOperator = 
			i:_UnaryOperator ws_nl*
			{ return i; }

_IncrementOperator="++" / "--"
IncrementOperator = 
			i:_IncrementOperator ws_nl*
			{ return i; }


IntegerLiteral=
		integer:valid_num+ ws_nl*
		{ return { tag:"integer", value:new Number(integer.join(''))}; }

FloatingPointLiteral=
		left:valid_num+ "."  right:valid_num+ ws_nl*
		{ return { tag:"float", value:new Number(left.join('') + '.' + right.join(''))}; }

StringLiteral='"' s:valid_str_char* '"' ws_nl*
	{ return { tag:"string", value:s.join('')}; }

valid_str_char=(!"\"" c:.)
 	{ return c; }

valid_num=[0-9]

valid_1st_idchar=[a-zA-Z_$]

valid_idchar=[0-9] / valid_1st_idchar

eos=";"

