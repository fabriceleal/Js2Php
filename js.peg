
statements=
		s:statement* ws_nl*
		{ return { tag: "statement_collection", value:s }}

statement=
		var_form_right_pad
	/	expression_right_pad
	/ 	return_operator_right_pad


expression_right_pad = e:expression right_pad
		{ return e; }

/*Anything that can be put inside parenthesis (it might not be inside parenthesis) */
expression= 
		c:clean_expression ws_nl*
		{ return c; }
/*	/	"(" ws_nl* c:clean_expression ")" ws_nl*
		{ return { tag: "parenthesis", expression: c }; }*/


clean_expression=var_set / comparative / literal / offsetable / function_application / id


function_application_expression_list_comma_item="," ws_nl* e:expression ws_nl*
		{ return e; }
function_application_expression_list=h:expression ws_nl* t:function_application_expression_list_comma_item*
		{ return [h].concat(t); }

// FIXME Curryed example f()()()
function_application=f:id "(" ws_nl* a:function_application_expression_list? ")" ws_nl*
		{ return { tag: "fun_app", fun:f, args:a }}


// Variable declaration / Value setting

declarables=var_name /* var_name */
assignables=offsetable / id /* var_name, array/object offset, object member */

var_set_right_pad=v:var_set right_pad
		{ return v; }

var_form_right_pad="var " ws_nl* head:var_decl tail:commas_var_decl* right_pad
		{ return { tag: "let_collection", value:[head].concat(tail) } }

commas_var_decl="," ws_nl* v:var_decl ws_nl*
		{ return v; }

// FIXME var a = b = c = 1 NOT SUPPORTED!!!
var_decl=
	 	var_name:declarables ws_nl* "=" ws_nl* var_value:expression
		{ return { tag: "let", id: var_name, value: var_value } }
	/	var_name:declarables ws_nl*
		{ return { tag: "let", id: var_name, value: undefined } }

var_set=
		var_name:assignables ws_nl* "=" ws_nl* var_value:expression
		{ return { tag: "let", id: var_name, value: var_value } }

// FIXME support this: a[0][1]
//	FIXME support this: a.getasd
// FIXME support this: a.getasd.setqwe()
offsetable_accessor=
		"[" ws_nl* o:expression "]" ws_nl*
		{ return { tag: "offsetable_accessor_as_arr", offset:o }; }
	/	"." ws_nl* o:property_name ws_nl*
		{ return { tag: "offsetable_accessor_as_obj", offset:o }; }

offsetable=
		container:id ws_nl* offset:offsetable_accessor+
		{ return { tag: "offsetable", id:container, offset:offset} }

// Comma operator 

// TODO
//comma_operator=

return_operator_right_pad=r:return_operator right_pad
		{ return r; }

return_operator="return" ws_nl* e:expression?
		{ return { tag:"return", value:e}; }


comp_op = "<=" / ">=" / "!=" / "==" / "<" / ">" / "<==" / ">==" / "!==" / "==="

// Arithmetics
comparative=
		left:add ws_nl* op:comp_op ws_nl* right:add ws_nl* 
		{ return { tag:"infix", operator:op, left:left, right:right } }

add=
		left:mult ws_nl* op:"+" ws_nl* right:add ws_nl* 
		{ return { tag:"infix", operator:op, left:left, right:right } }

mult=
		left:primitive ws_nl* op:[\*\/] ws_nl* right:add ws_nl* 
		{ return { tag:"infix", operator:op, left:left, right:right } }

primitive=
		n:number_literal ws_nl* 
		{ return n; }
	/	"(" ws_nl* a:add ")" ws_nl*
		{ return a; }

// Literals

literal_right_pad = l:clean_literal right_pad
		{ return l; }

literal=l:clean_literal ws_nl*
		{ return l; }

clean_literal=function_literal / object_literal / array_literal / string_literal / number_literal

//// Array literal
comma_literal = "," ws_nl* v:literal ws_nl*
		{ return v; }

array_literal=
		"[" ws_nl* "]"
		{ return { tag:"array_literal", value:[]} }
	/	"[" ws_nl* head:literal tail:comma_literal* ws_nl* "]"
		{ return { tag:"array_literal", value:[head].concat(tail) }}


//// Object literal
comma_object_literal_entry_pair = "," ws_nl* v:object_literal_entry_pair ws_nl*
		{ return v; }

object_literal_entry_pair_valid_key = string_literal / number_literal / id

object_literal_entry_pair=key:object_literal_entry_pair_valid_key ws_nl* ":" ws_nl* value:literal
		{ return { tag: "object_entry", key:key, value:value }}

object_literal=
		"{" ws_nl* "}"
		{ return { tag:"object_literal", value:[]} }
	/	"{" ws_nl* head:object_literal_entry_pair tail:comma_object_literal_entry_pair* ws_nl* "}"
		{ return { tag:"object_literal", value:[head].concat(tail) }}

//// Function literal

function_comma_arg= "," ws_nl* e:id ws_nl*
		{ return e; }

function_list_args=h:id t:function_comma_arg*
		{ return [h].concat(t) }
		/ ws_nl* 
		{ return []; }

function_literal=
		"function" ws_nl* name:id? ws_nl* "(" a:function_list_args "){" 
			ws_nl* body:statements 
		"}"
		{ return { tag: "function_literal", name:name, args:a, body:body } }

//// Number literal - simple for now; only decimal notation
number_literal=
		left:valid_num+ "."  right:valid_num+
		{ return { tag:"number_literal", value:new Number(left.join('') + '.' + right.join(''))}; }
	/	integer:valid_num+
		{ return { tag:"number_literal", value:new Number(integer.join(''))}; }

string_literal='"' s:valid_str_char* '"'
		{ return { tag: "string_literal", value:s.join('') }; }

//// A var reference; can be also used as a "symbol", for the key in an Object

// var reference and declaration are separated for processing reasons...

id = h:valid_1st_idchar t:valid_idchar*
		{ return { tag:"id", name:h + t.join('')}}

var_name = h:valid_1st_idchar t:valid_idchar*
		{ return { tag:"iddeclr", name:h + t.join('')}}

property_name = h:valid_1st_idchar t:valid_idchar*
		{ return { tag:"property_name", name:h + t.join('')}}

// BASE 

right_pad=
		eos? ws_nl*

ws_nl=
		ws 
	/ 	nl

nl=
		"\r\n" 
	/  "\r" 
	/  "\n"

ws=[ \w\t]

valid_str_char=(!"\"" c:.)
 	{ return c; }

valid_num=[0-9]

// FIXME not exhaustive, for now ...
valid_1st_idchar=[a-zA-Z_$]

valid_idchar=[0-9] / valid_1st_idchar

eos=";"

