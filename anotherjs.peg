/*
	From here: http://tomcopeland.blogs.com/EcmaScript.html
	Yet in BNF format.
*/

start=Program

Program 	= 	SourceElements
SourceElements = 	SourceElement*
SourceElement 	= 	FunctionDeclaration
	/ 	StatementWsNl

Statement 	= 	Block
	/// 	JScriptVarStatement
	/ 	VariableStatement
	/ 	EmptyStatement
	/ 	LabelledStatement
	/ 	ExpressionStatement
	/ 	IfStatement
	/ 	IterationStatement
	/ 	ContinueStatement
	/ 	BreakStatement
	/ 	ImportStatement
	/ 	ReturnStatement
	/ 	WithStatement
	/ 	SwitchStatement
	/ 	ThrowStatement
	/ 	TryStatement

FunctionDeclaration	= "function" Identifier "(" FormalParameterList/*?*/ ")" FunctionBody WsNlStream ";"? WsNlStream

FunctionExpression 	= 
		"function" id:Identifier? "(" pars:FormalParameterList ")" body:FunctionBody WsNlStream
		{ return {tag:"functionExpr", name:id, pars:pars, body:body}; }

FunctionBody 	= 	"{" SourceElements? "}" WsNlStream

FormalParameterListTail = "," WsNlStream i:Identifier
		{ return i; }

FormalParameterList 	= 	h:Identifier t:FormalParameterListTail*
		{ return { tag:"formalParameterList", value:[h].concat(t)}; }

ExpressionStatement 	= 	Expression ";"? WsNlStream

PrimaryExpression = 
		"this"
	/ 	ObjectLiteral
	/ 	( "(" WsNlStream e:Expression WsNlStream ")" )
		{ return e; }
	/ 	Identifier
	/ 	ArrayLiteral
	/ 	Literal

DECIMAL_LITERAL= "1"
HEX_INTEGER_LITERAL= "0x1"
STRING_LITERAL= 
		"'" a:(!"'" .)* "'"
		{ return { tag:"string_literal", value:a.map(function(e){return e.join('');}).join('')}; }
	/	"\"" a:(!"\"" .)* "\""
		{ return { tag:"string_literal", value:a.map(function(e){return e.join('');}).join('')}; }

BOOLEAN_LITERAL= "true" / "false"
NULL_LITERAL= "NULL" / "null"
REGULAR_EXPRESSION_LITERAL="blah"
IDENTIFIER_NAME="id"

LITERAL	= ( DECIMAL_LITERAL / HEX_INTEGER_LITERAL / STRING_LITERAL / BOOLEAN_LITERAL / NULL_LITERAL / REGULAR_EXPRESSION_LITERAL )
Literal 	= 	
		l:LITERAL WsNlStream
		{ return { tag:"literal", value:l}; }

Identifier 	= 	
		i:IDENTIFIER_NAME WsNlStream
		{ return { tag:"id", name:i}; }

ArrayLiteral 	= 	"[" ( ( Elision )? "]" / ElementList Elision "]" / ( ElementList )? "]" )
ElementList 	= 	( Elision )? AssignmentExpression ( Elision AssignmentExpression )*
Elision 	= 	( "," )+

ObjectLiteral 	= 	"{" ls:PropertyNameAndValueList? "}"
		{ return { tag:"object", value:ls}; }

PropertyNameAndValueListTail	=  
		"," p:PropertyNameAndValue
		{ return [p]; }
	/	","
		{ return []; }

PropertyNameAndValueList 	= 	
		h:PropertyNameAndValue t:PropertyNameAndValueListTail*
		{ return Array.prototype.concat.apply([h], t); }
		
PropertyNameAndValue 	= 	
		key:PropertyName ":" value:AssignmentExpression
		{ return { tag:"objectSlot", key:key, value:value}; }

PropertyName 	= 	
		Identifier
	/ 	STRING_LITERAL
	/ 	DECIMAL_LITERAL

MemberExpression 	= 	
		( ( FunctionExpression / PrimaryExpression ) ( MemberExpressionPart )* )
	/ 	AllocationExpression

MemberExpressionForIn 	= 	( ( FunctionExpression / PrimaryExpression ) ( MemberExpressionPart )* )
AllocationExpression 	= 	( "new" MemberExpression ( ( Arguments ( MemberExpressionPart )* )* ) )

MemberExpressionPart 	= 	
		( "[" e:Expression "]" )
		{ return { tag:"memberExpressionPartOffset", value:e}; }
	/ 	( "." id:Identifier )
		{ return { tag:"memberExpressionPartDot", value: id}; }

CallExpression 	= 	MemberExpression Arguments CallExpressionPart*
CallExpressionForIn 	= 	MemberExpressionForIn Arguments CallExpressionPart*

CallExpressionPart 	= 	
		a:Arguments
		{ return { tag:"callExpressionPartArgs", value:a }; }
	/ 	( "[" e:Expression "]" )
		{ return { tag:"callExpressionPartOffset", value:e }; }
	/ 	( "." i:Identifier )
		{ return { tag:"callExpressionPartDot", value:i}; }

Arguments 	= 	"(" ( ArgumentList )? ")"
ArgumentList 	= 	AssignmentExpression ( "," AssignmentExpression )*
LeftHandSideExpression 	= 	CallExpression
	/ 	MemberExpression
LeftHandSideExpressionForIn 	= 	CallExpressionForIn
	/ 	MemberExpressionForIn
PostfixExpression 	= 	LeftHandSideExpression ( PostfixOperator )?
PostfixOperator 	= 	( "++" / "--" )
UnaryExpression 	= 	( PostfixExpression / ( UnaryOperator UnaryExpression )+ )
UnaryOperator 	= 	( "delete" / "void" / "typeof" / "++" / "--" / "+" / "-" / "~" / "!" )
MultiplicativeExpression 	= 	UnaryExpression ( MultiplicativeOperator UnaryExpression )*
MultiplicativeOperator 	= 	( "*" / "/" / "%" )
AdditiveExpression 	= 	MultiplicativeExpression ( AdditiveOperator MultiplicativeExpression )*
AdditiveOperator 	= 	( "+" / "-" )
ShiftExpression 	= 	AdditiveExpression ( ShiftOperator AdditiveExpression )*
ShiftOperator 	= 	( "<<" / ">>" / ">>>" )
RelationalExpression 	= 	ShiftExpression ( RelationalOperator ShiftExpression )*
RelationalOperator 	= 	( "<" / ">" / "<=" / ">=" / "instanceof" / "in" )
RelationalExpressionNoIn 	= 	ShiftExpression ( RelationalNoInOperator ShiftExpression )*
RelationalNoInOperator 	= 	( "<" / ">" / "<=" / ">=" / "instanceof" )
EqualityExpression 	= 	RelationalExpression ( EqualityOperator RelationalExpression )*
EqualityExpressionNoIn 	= 	RelationalExpressionNoIn ( EqualityOperator RelationalExpressionNoIn )*
EqualityOperator 	= 	( "==" / "!=" / "===" / "!==" )
BitwiseANDExpression 	= 	EqualityExpression ( BitwiseANDOperator EqualityExpression )*
BitwiseANDExpressionNoIn 	= 	EqualityExpressionNoIn ( BitwiseANDOperator EqualityExpressionNoIn )*
BitwiseANDOperator 	= 	"&"
BitwiseXORExpression 	= 	BitwiseANDExpression ( BitwiseXOROperator BitwiseANDExpression )*
BitwiseXORExpressionNoIn 	= 	BitwiseANDExpressionNoIn ( BitwiseXOROperator BitwiseANDExpressionNoIn )*
BitwiseXOROperator 	= 	"^"
BitwiseORExpression 	= 	BitwiseXORExpression ( BitwiseOROperator BitwiseXORExpression )*
BitwiseORExpressionNoIn 	= 	BitwiseXORExpressionNoIn ( BitwiseOROperator BitwiseXORExpressionNoIn )*
BitwiseOROperator 	= 	"|"
LogicalANDExpression 	= 	BitwiseORExpression ( LogicalANDOperator BitwiseORExpression )*
LogicalANDExpressionNoIn 	= 	BitwiseORExpressionNoIn ( LogicalANDOperator BitwiseORExpressionNoIn )*
LogicalANDOperator 	= 	"&&"
LogicalORExpression 	= 	LogicalANDExpression ( LogicalOROperator LogicalANDExpression )*
LogicalORExpressionNoIn 	= 	LogicalANDExpressionNoIn ( LogicalOROperator LogicalANDExpressionNoIn )*
LogicalOROperator 	= 	"||"
ConditionalExpression 	= 	LogicalORExpression ( "?" AssignmentExpression ":" AssignmentExpression )?
ConditionalExpressionNoIn 	= 	LogicalORExpressionNoIn ( "?" AssignmentExpression ":" AssignmentExpressionNoIn )?
AssignmentExpression 	= 	( LeftHandSideExpression AssignmentOperator AssignmentExpression / ConditionalExpression )
AssignmentExpressionNoIn 	= 	( LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn / ConditionalExpressionNoIn )
AssignmentOperator 	= 	( "=" / "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / ">>>=" / "&=" / "^=" / "/=" )
Expression 	= 	AssignmentExpression ( "," AssignmentExpression )* WsNlStream
ExpressionNoIn 	= 	AssignmentExpressionNoIn ( "," AssignmentExpressionNoIn )*

StatementWsNl = Statement WsNlStream

Block 	= 	"{" ( StatementList )? "}"
StatementList 	= 	( StatementWsNl )+
VariableStatement 	= 	"var " VariableDeclarationList ( ";" )?
VariableDeclarationList 	= 	VariableDeclaration ( "," VariableDeclaration )*
VariableDeclarationListNoIn 	= 	VariableDeclarationNoIn ( "," VariableDeclarationNoIn )*
VariableDeclaration 	= 	Identifier ( Initialiser )?
VariableDeclarationNoIn 	= 	Identifier ( InitialiserNoIn )?
Initialiser 	= 	"=" AssignmentExpression
InitialiserNoIn 	= 	"=" AssignmentExpressionNoIn
EmptyStatement 	= 	";"

IfStatement 	= 	"if" "(" Expression ")" StatementWsNl ( "else" StatementWsNl )?
IterationStatement 	= 	( "do" StatementWsNl "while" "(" Expression ")" ( ";" )? )
	/ 	( "while" "(" Expression ")" StatementWsNl )
	/ 	( "for" "(" ( ExpressionNoIn )? ";" ( Expression )? ";" ( Expression )? ")" StatementWsNl )
	/ 	( "for" "(" "var" VariableDeclarationList ";" ( Expression )? ";" ( Expression )? ")" StatementWsNl )
	/ 	( "for" "(" "var" VariableDeclarationNoIn "in" Expression ")" StatementWsNl )
	/ 	( "for" "(" LeftHandSideExpressionForIn "in" Expression ")" StatementWsNl )
ContinueStatement 	= 	"continue" ( Identifier )? ( ";" )?
BreakStatement 	= 	"break" ( Identifier )? ( ";" )?

ReturnStatement 	= 	"return" WsNlStream e:Expression? ";"? WsNlStream
		{ return { tag:"return", value:e }; }

WithStatement 	= 	"with" "(" Expression ")" StatementWsNl
SwitchStatement 	= 	"switch" "(" Expression ")" CaseBlock
CaseBlock 	= 	"{" ( CaseClauses )? ( "}" / DefaultClause ( CaseClauses )? "}" )
CaseClauses 	= 	( CaseClause )+
CaseClause 	= 	( ( "case" Expression ":" ) ) ( StatementList )?
DefaultClause 	= 	( ( "default" ":" ) ) ( StatementList )?
LabelledStatement 	= 	Identifier ":" StatementWsNl
ThrowStatement 	= 	"throw" Expression ( ";" )?
TryStatement 	= 	"try" Block ( ( Finally / Catch ( Finally )? ) )
Catch 	= 	"catch" "(" Identifier ")" Block
Finally 	= 	"finally" Block


ImportStatement 	= 	"import" Name ( "." "*" )? ";"

NameTail="." t:IDENTIFIER_NAME
		{ return t; }
Name 	= 	h:IDENTIFIER_NAME t:NameTail*
		{ return { tag:"name", value:[h].concat(t)}; }

//JScriptVarStatement 	= 	"var " JScriptVarDeclarationList ( ";" )?
//JScriptVarDeclarationList 	= 	JScriptVarDeclaration ( "," JScriptVarDeclaration )*
//JScriptVarDeclaration 	= 	Identifier ":" IDENTIFIER_NAME ( Initialiser )?


WsNlStream=WsNl*
WsNl= "\r" / "\n" / "\r\n" / [ \w\t]

