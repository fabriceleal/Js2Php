/*
	From here: http://tomcopeland.blogs.com/EcmaScript.html (in BNF format).
	Adapted by Fabrice.
*/

start				= Program

Program			= SourceElements
SourceElements = SourceElement*
SourceElement 	= FunctionDeclaration / StatementWsNl
Statement 		= Block / VariableStatement / EmptyStatement / LabelledStatement / ReturnStatement / IfStatement
						/ ExpressionStatement / IterationStatement / ContinueStatement / BreakStatement / ImportStatement
						/ 	WithStatement / SwitchStatement / ThrowStatement / TryStatement

/*
Block / VariableStatement / EmptyStatement / LabelledStatement / ExpressionStatement
					/ 	IfStatement / IterationStatement / ContinueStatement / BreakStatement / ImportStatement
					/ 	ReturnStatement / WithStatement / SwitchStatement / ThrowStatement / TryStatement
*/


FunctionDeclaration =
		"function" WsNlStream id:Identifier "(" WsNlStream pars:FormalParameterList ")" WsNlStream body:FunctionBody ";"? WsNlStream
		{ return { tag:"functionDecl", name:id, pars:pars, body:body}; }

FunctionExpression =
		"function" WsNlStream id:Identifier? "(" WsNlStream pars:FormalParameterList ")" WsNlStream body:FunctionBody
		{ return { tag:"functionExpr", name:id, pars:pars, body:body}; }


FunctionBody =
		"{" WsNlStream code:SourceElements? "}" WsNlStream
		{ return { tag:"functionBody", code:code}; }

FormalParameterListTail =
		"," WsNlStream i:Identifier
		{ return i; }

FormalParameterList =
		h:Identifier t:FormalParameterListTail*
		{ return { tag:"formalParameterList", value:[h].concat(t)}; }

ExpressionStatement =
		e:Expression ";"? WsNlStream
		{ return { tag:"expression", value:e}; }

PrimaryExpression = 
		"this" WsNlStream
		{ return { tag:"thisRef"}; }
	/ 	ObjectLiteral
	/ 	"(" WsNlStream e:Expression WsNlStream ")" WsNlStream
		{ return e; }
	/ 	Identifier
	/ 	ArrayLiteral
	/ 	Literal

// Literals

DECIMAL_LITERAL = 
		d:DECIMAL_DIGIT+
		{ return { tag:"number_literal", value:new Number(d.join(''))}; }

// I dont care about preserving hex literals. do you?
HEX_INTEGER_LITERAL = 
		"0x" d:HEX_DIGIT+
		{ return { tag:"number_literal", value:new Number("0x" + d.join(''))}; }

STRING_LITERAL = 
		"'" a:(!"'" .)* "'" WsNlStream
		{ return { tag:"string_literal", value:a.map(function(e){return e.join('');}).join('')}; }
	/	"\"" a:(!"\"" .)* "\"" WsNlStream
		{ return { tag:"string_literal", value:a.map(function(e){return e.join('');}).join('')}; }

BOOLEAN_LITERAL = 
		"true"	WsNlStream
		{ return { tag:"bool_literal", value:true}; }
	/	"false"	WsNlStream
		{ return { tag:"bool_literal", value:false}; }

NULL_LITERAL = 
		"null" 	WsNlStream
		{ return { tag:"null_literal"}; }

REGULAR_EXPRESSION_LITERAL	= "blah"

// Identifiers
HEX_DIGIT						= [A-F0-9]
DECIMAL_DIGIT					= [0-9]
IDENTIFIER_NAME_CHAR			= IDENTIFIER_NAME_1ST_CHAR / DECIMAL_DIGIT
IDENTIFIER_NAME_1ST_CHAR	= [a-zA-Z]
IDENTIFIER_NAME				= 
		h:IDENTIFIER_NAME_1ST_CHAR t:IDENTIFIER_NAME_CHAR*
		{ return [h].concat(t).join(''); }


LITERAL	= DECIMAL_LITERAL / HEX_INTEGER_LITERAL / STRING_LITERAL / BOOLEAN_LITERAL / NULL_LITERAL / REGULAR_EXPRESSION_LITERAL
Literal 	= 	
		l:LITERAL WsNlStream
		{ return { tag:"literal", value:l}; }

Identifier = 	
		i:IDENTIFIER_NAME WsNlStream
		{ return { tag:"id", name:i}; }

ArrayLiteral = 	
		"[" Elision? "]"
	/ 	"[" ElementList Elision "]" 
	/ 	"[" ElementList? "]"

ElementList = 	
		Elision? AssignmentExpression ( Elision AssignmentExpression )*

Elision 	= 	
		","+

ObjectLiteral 	= 	"{" WsNlStream ls:PropertyNameAndValueList? "}"
		{ return { tag:"object", value:ls}; }

PropertyNameAndValueListTail	=  
		"," WsNlStream p:PropertyNameAndValue
		{ return [p]; }
	/	"," WsNlStream
		{ return []; }

PropertyNameAndValueList 	= 	
		h:PropertyNameAndValue t:PropertyNameAndValueListTail*
		{ return Array.prototype.concat.apply([h], t); }
		
PropertyNameAndValue 	= 	
		key:PropertyName ":" WsNlStream value:AssignmentExpression
		{ return { tag:"objectSlot", key:key, value:value}; }

PropertyName 	= 	
		Identifier
	/ 	STRING_LITERAL
	/ 	DECIMAL_LITERAL

MemberExpression 	= 	
		( ( FunctionExpression / PrimaryExpression ) ( MemberExpressionPart )* )
	/ 	AllocationExpression

MemberExpressionForIn 	= 	
		( ( FunctionExpression / PrimaryExpression ) ( MemberExpressionPart )* )

AllocationExpression 	= 	
		( "new" MemberExpression ( ( Arguments ( MemberExpressionPart )* )* ) )

MemberExpressionPart 	= 	
		"[" WsNlStream e:Expression "]" WsNlStream
		{ return { tag:"memberExpressionPartOffset", value:e}; }
	/ 	"." WsNlStream id:Identifier
		{ return { tag:"memberExpressionPartDot", value: id}; }

CallExpression = 	MemberExpression Arguments CallExpressionPart*
CallExpressionForIn = MemberExpressionForIn Arguments CallExpressionPart*

CallExpressionPart = 	
		a:Arguments
		{ return { tag:"callExpressionPartArgs", value:a }; }
	/ 	"[" WsNlStream e:Expression "]" WsNlStream
		{ return { tag:"callExpressionPartOffset", value:e }; }
	/ 	"." WsNlStream i:Identifier
		{ return { tag:"callExpressionPartDot", value:i}; }

Arguments = 
		"(" WsNlStream a:ArgumentList? ")" WsNlStream
		{ return { tag:"arguments", value:a}; }

ArgumentListTail	= 
		"," WsNlStream i:AssignmentExpression
		{ return i; }

ArgumentList = 
		h:AssignmentExpression t:ArgumentListTail*
		{ return [h].concat(t); }

LeftHandSideExpression 			= CallExpression / MemberExpression
LeftHandSideExpressionForIn 	= CallExpressionForIn / MemberExpressionForIn

PostfixExpression 			= 	LeftHandSideExpression PostfixOperator?
PostfixOperator 				= 	"++" / "--"
UnaryExpression 				= 	( PostfixExpression / ( UnaryOperator UnaryExpression )+ )
UnaryOperator 					= 	"delete" / "void" / "typeof" / "++" / "--" / "+" / "-" / "~" / "!"

// Multiplicative
MultiplicativeExpression 	= 	UnaryExpression ( MultiplicativeOperator UnaryExpression )*
MultiplicativeOperator 		= 	"*" / "/" / "%"

// Additive
AdditiveExpression 			= 	MultiplicativeExpression (AdditiveOperator MultiplicativeExpression)*

AdditiveOperator 				= 	"+" / "-"

// Shift
ShiftExpression 				= 	AdditiveExpression (ShiftOperator AdditiveExpression)*
ShiftOperator 					= 	"<<" / ">>" / ">>>"

// Relational
RelationalExpression 		= 	ShiftExpression (RelationalOperator ShiftExpression)*
RelationalOperator 			= 	"<" / ">" / "<=" / ">=" / "instanceof" / "in"

RelationalExpressionNoIn 	= 	ShiftExpression (RelationalNoInOperator ShiftExpression)*

RelationalNoInOperator 		= 	"<" / ">" / "<=" / ">=" / "instanceof"

// Equality
EqualityExpression 			= 	
		left:RelationalExpression op:EqualityOperator right:RelationalExpression
		{ return { tag:"eq", left:left, op:op, right:right}; }
	/	RelationalExpression

EqualityExpressionNoIn 		= 	
		left:RelationalExpressionNoIn op:EqualityOperator right:RelationalExpressionNoIn
		{ return { tag:"eqNoIn", left:left, op:op, right:right}; }
	/	RelationalExpressionNoIn

EqualityOperator 				= 	"==" / "!=" / "===" / "!=="

// ...
BitwiseANDExpression 		= 	EqualityExpression (BitwiseANDOperator EqualityExpression)*

BitwiseANDExpressionNoIn 	= 	EqualityExpressionNoIn (BitwiseANDOperator EqualityExpressionNoIn)*

BitwiseANDOperator 			= 	"&"

// ...
BitwiseXORExpression 		= 	BitwiseANDExpression (BitwiseXOROperator BitwiseANDExpression)*

BitwiseXORExpressionNoIn 	= 	BitwiseANDExpressionNoIn (BitwiseXOROperator BitwiseANDExpressionNoIn)*


BitwiseXOROperator 			= 	"^"

// ...
BitwiseORExpression 			= 	BitwiseXORExpression (BitwiseOROperator BitwiseXORExpression)*

BitwiseORExpressionNoIn 	= 	BitwiseXORExpressionNoIn (BitwiseOROperator BitwiseXORExpressionNoIn)*

BitwiseOROperator 			= 	"|"

// LogicalAND
LogicalANDExpression 		= 	
		left:BitwiseORExpression op:LogicalANDOperator right:BitwiseORExpression
		{ return { tag:"and", left:left, op:op, right:right}; }
	/	BitwiseORExpression

LogicalANDExpressionNoIn 	= 	
		left:BitwiseORExpressionNoIn op:LogicalANDOperator right:BitwiseORExpressionNoIn
		{ return { tag:"andNoIn", left:left, op:op, right:right}; }
	/	BitwiseORExpressionNoIn

LogicalANDOperator 			= 	"&&"

// LogicalOR
LogicalORExpression 			= 	
		LogicalANDExpression LogicalOROperator LogicalANDExpression
		{ return { tag:"or", left:left, op:op, right:right}; }
	/	LogicalANDExpression

LogicalORExpressionNoIn 	= 	
		left:LogicalANDExpressionNoIn op:LogicalOROperator right:LogicalANDExpressionNoIn
		{ return { tag:"orNoIn", left:left, op:op, right:right}; }
	/	LogicalANDExpressionNoIn

LogicalOROperator 			= 	"||"

// ...
ConditionalExpression 		= 	LogicalORExpression ( "?" AssignmentExpression ":" AssignmentExpression )?
ConditionalExpressionNoIn 	= 	LogicalORExpressionNoIn ( "?" AssignmentExpression ":" AssignmentExpressionNoIn )?

// Assignment
AssignmentExpression 		= 	
		l:LeftHandSideExpression op:AssignmentOperator r:AssignmentExpression 
		{ return { tag:"assignment", left:l, operator:op, right:r}; }
	/ 	ConditionalExpression

AssignmentExpressionNoIn 	= 	
		l:LeftHandSideExpression op:AssignmentOperator r:AssignmentExpressionNoIn 
		{ return { tag:"assignmentNoIn", left:l, operator:op, right:r}; }
	/	ConditionalExpressionNoIn

AssignmentOperator 			= 	"=" / "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / ">>>=" / "&=" / "^=" / "/="

// ...
Expression 	= 	AssignmentExpression ( "," AssignmentExpression )* WsNlStream
ExpressionNoIn 	= 	AssignmentExpressionNoIn ( "," AssignmentExpressionNoIn )*

StatementWsNl = s:Statement WsNlStream
		{ return s; }

Block = 
		"{" WsNlStream l:StatementList? "}" WsNlStream
		{ return { tag:"block", value:l}; }

StatementList 	= 	
		ss:StatementWsNl+
		{ return { tag:"statementList", value:ss}; }

VariableStatement 	= 	
		"var " WsNlStream l:VariableDeclarationList ";"? WsNlStream
		{ return {tag:"varStatement", value:l}; }

// VariableDeclarationList
VariableDeclarationListTail=
		"," WsNlStream i:VariableDeclaration
		{ return i; }
VariableDeclarationList =
		h:VariableDeclaration t:VariableDeclarationListTail*
		{ return [h].concat(t); }

// VariableDeclarationListNoIn
VariableDeclarationListNoInTail=
		"," WsNlStream i:VariableDeclarationNoIn
		{ return i;}
VariableDeclarationListNoIn = 
		h:VariableDeclarationNoIn t:VariableDeclarationListNoInTail*
		{ return [h].concat(t); }

// VariableDeclaration*
VariableDeclaration 	= 	
		id:Identifier init:Initialiser?
		{ return { tag:"declaration", name:id, init:init}; }

VariableDeclarationNoIn = 
		id:Identifier init:InitialiserNoIn?
		{ return { tag:"declarationNoIn", name:id, init:init}; }

// Initialiser*
Initialiser 	= 	
		"=" WsNlStream e:AssignmentExpression
		{ return { tag:"initialiser", value:e}; }

InitialiserNoIn 	= 	
		"=" WsNlStream e:AssignmentExpressionNoIn
		{ return { tag:"initialiserNoIn", value:e}; }

EmptyStatement 	= 	WsNlStream ";" WsNlStream
		{ return { tag:"empty"}; }

IfStatement 	= 	
		"if" WsNlStream "(" WsNlStream e:Expression ")" WsNlStream truebr:StatementWsNl "else" WsNlStream falsebr:StatementWsNl
		{ return { tag:"if", condition:e, truebr:truebr, falsebr:falsebr}; }
	/	"if" WsNlStream "(" WsNlStream e:Expression ")" WsNlStream truebr:StatementWsNl
		{ return { tag:"if", condition:e, truebr:truebr, falsebr:null}; }

IterationStatement 	= 	
		"do" WsNlStream StatementWsNl "while" WsNlStream "(" WsNlStream Expression ")" WsNlStream  (";" WsNlStream)? 
	/ 	"while" WsNlStream "(" WsNlStream Expression ")" WsNlStream StatementWsNl
	/ 	"for" WsNlStream "(" WsNlStream ExpressionNoIn? ";" WsNlStream Expression? ";" WsNlStream Expression? ")" WsNlStream StatementWsNl
	/ 	"for" WsNlStream "(" WsNlStream "var" WsNlStream VariableDeclarationList ";" WsNlStream Expression? ";" WsNlStream Expression? ")" WsNlStream StatementWsNl
	/ 	"for" WsNlStream "(" WsNlStream "var" WsNlStream VariableDeclarationNoIn "in" WsNlStream Expression ")" WsNlStream StatementWsNl
	/ 	"for" WsNlStream "(" WsNlStream LeftHandSideExpressionForIn "in" WsNlStream Expression ")" WsNlStream StatementWsNl

ContinueStatement = 	
		"continue" WsNlStream id:Identifier? (";" WsNlStream)?
		{ return { tag: "continue", id:id}; }

BreakStatement 	= 	
		"break" WsNlStream id:Identifier? (";" WsNlStream)?
		{ return { tag: "break", id:id}; }

ReturnStatement 	= 	
		"return" WsNlStream e:Expression? (";" WsNlStream)?
		{ return { tag:"return", value:e }; }

WithStatement 		= 	
		"with" WsNlStream "(" WsNlStream e:Expression ")" WsNlStream s:StatementWsNl
		{ return { tag:"with", expression:e, code:s }; }

SwitchStatement 	= 	
		"switch" WsNlStream "(" WsNlStream e:Expression ")" WsNlStream c:CaseBlock
		{ return { tag:"switch", expression:e, cases:c }; }

CaseBlock 	= 	"{" ( CaseClauses )? ( "}" / DefaultClause ( CaseClauses )? "}" )

CaseClauses 	= 	( CaseClause )+

CaseClause 	= 	( ( "case" Expression ":" ) ) ( StatementList )?

DefaultClause 	= 	( ( "default" ":" ) ) ( StatementList )?

LabelledStatement = 	
		i:Identifier ":" s:StatementWsNl
		{ return { tag:"labelled", id:i, statement:s}; }

ThrowStatement	=
		"throw" e:Expression ";"?
		{ return { tag:"throw", value:e}}

TryStatement 	= 	
		"try" WsNlStream b:Block c:Catch f:Finally
		{ return { tag:"try", block:b, catchBlock:c, 	finallyBlock:f};    }
	/	"try" WsNlStream b:Block f:Finally
		{ return { tag:"try", block:b, catchBlock:null, finallyBlock:f}; 	  }
	/	"try" WsNlStream b:Block c:Catch
		{ return { tag:"try", block:b, catchBlock:c, 	finallyBlock:null}; }

Catch 	=
		"catch" WsNlStream "(" WsNlStream i:Identifier ")" WsNlStream b:Block
		{ return { tag:"catch", id:i, block:b}; }

Finally 	=
		"finally" WsNlStream b:Block
		{ return { tag:"finally", block:b}; }


ImportStatement = "import" Name ( "." "*" )? ";"

NameTail="." t:IDENTIFIER_NAME
		{ return t; }
Name 	= 	h:IDENTIFIER_NAME t:NameTail*
		{ return { tag:"name", value:[h].concat(t)}; }

//JScriptVarStatement 	= 	"var " JScriptVarDeclarationList ( ";" )?
//JScriptVarDeclarationList 	= 	JScriptVarDeclaration ( "," JScriptVarDeclaration )*
//JScriptVarDeclaration 	= 	Identifier ":" IDENTIFIER_NAME ( Initialiser )?


WsNlStream=WsNl*
WsNl= "\r" / "\n" / "\r\n" / [ \w\t]

